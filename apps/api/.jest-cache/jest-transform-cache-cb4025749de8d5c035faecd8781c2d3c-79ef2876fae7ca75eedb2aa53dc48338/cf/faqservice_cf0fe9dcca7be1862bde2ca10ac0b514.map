{"file":"/home/luisneto98/Documentos/Code/monorepo-vtex/apps/api/src/modules/faq/faq.service.ts","mappings":"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","names":[],"sources":["/home/luisneto98/Documentos/Code/monorepo-vtex/apps/api/src/modules/faq/faq.service.ts"],"sourcesContent":["import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model, Schema as MongooseSchema } from 'mongoose';\nimport { Faq, FaqDocument } from './schemas/faq.schema';\nimport { FaqCategory, FaqCategoryDocument } from './schemas/faq-category.schema';\nimport { CreateFaqDto } from './dto/create-faq.dto';\nimport { UpdateFaqDto } from './dto/update-faq.dto';\nimport { FaqFilterDto } from './dto/faq-filter.dto';\nimport { CreateFaqCategoryDto } from './dto/create-faq-category.dto';\nimport { UpdateFaqCategoryDto } from './dto/update-faq-category.dto';\nimport { PaginatedResponse } from '@common/dto/pagination.dto';\nimport { FAQ_CONSTANTS } from './faq.constants';\n\n@Injectable()\nexport class FaqService {\n  constructor(\n    @InjectModel(Faq.name) private faqModel: Model<FaqDocument>,\n    @InjectModel(FaqCategory.name) private faqCategoryModel: Model<FaqCategoryDocument>,\n  ) {}\n\n  // FAQ CRUD\n  async createFaq(createFaqDto: CreateFaqDto): Promise<FaqDocument> {\n    // Verify category exists\n    const category = await this.faqCategoryModel.findById(createFaqDto.category);\n    if (!category) {\n      throw new NotFoundException(`FAQ category with ID ${createFaqDto.category} not found`);\n    }\n\n    // Auto-generate order if not provided\n    if (createFaqDto.order === undefined) {\n      const maxOrderFaq = await this.faqModel\n        .findOne({\n          category: createFaqDto.category,\n          deletedAt: null,\n        })\n        .sort({ order: -1 })\n        .exec();\n\n      createFaqDto.order = maxOrderFaq ? maxOrderFaq.order + 1 : 0;\n    } else {\n      // Check for order conflicts within the category if order is provided\n      const existingFaq = await this.faqModel.findOne({\n        category: createFaqDto.category,\n        order: createFaqDto.order,\n        deletedAt: null,\n      });\n\n      if (existingFaq) {\n        throw new ConflictException('Another FAQ with this order already exists in this category');\n      }\n    }\n\n    const createdFaq = new this.faqModel(createFaqDto);\n    return createdFaq.save();\n  }\n\n  async findAllFaqs(filterDto: FaqFilterDto): Promise<PaginatedResponse<FaqDocument>> {\n    const { page = 1, limit = 20, sort, search, category, isVisible, lang } = filterDto;\n\n    const query: any = { deletedAt: null };\n\n    if (search) {\n      const searchFields = ['question.pt-BR', 'question.en', 'answer.pt-BR', 'answer.en'];\n      if (lang) {\n        // If language specified, prioritize search in that language\n        const langFields = [`question.${lang}`, `answer.${lang}`];\n        query.$or = [\n          ...langFields.map((field) => ({ [field]: { $regex: search, $options: 'i' } })),\n          ...searchFields.map((field) => ({ [field]: { $regex: search, $options: 'i' } })),\n        ];\n      } else {\n        query.$or = searchFields.map((field) => ({ [field]: { $regex: search, $options: 'i' } }));\n      }\n    }\n\n    if (category) {\n      query.category = category;\n    }\n\n    if (typeof isVisible !== 'undefined') {\n      query.isVisible = isVisible;\n    }\n\n    const skip = (page - 1) * limit;\n\n    let sortOptions: any = { 'category.order': 1, order: 1 };\n    if (sort) {\n      sortOptions = {};\n      const sortFields = sort.split(',');\n      for (const field of sortFields) {\n        if (field.startsWith('-')) {\n          sortOptions[field.substring(1)] = -1;\n        } else {\n          sortOptions[field] = 1;\n        }\n      }\n    }\n\n    const [data, total] = await Promise.all([\n      this.faqModel\n        .find(query)\n        .populate('category')\n        .sort(sortOptions)\n        .skip(skip)\n        .limit(limit)\n        .exec(),\n      this.faqModel.countDocuments(query),\n    ]);\n\n    return {\n      success: true,\n      data,\n      metadata: {\n        total,\n        page,\n        limit,\n        hasNext: skip + data.length < total,\n        hasPrev: page > 1,\n      },\n    };\n  }\n\n  async findFaqById(id: string): Promise<FaqDocument> {\n    // Use atomic operation to increment view count and return updated document\n    const faq = await this.faqModel\n      .findOneAndUpdate(\n        {\n          _id: id,\n          deletedAt: null,\n        },\n        {\n          $inc: { viewCount: 1 },\n        },\n        {\n          new: true, // Return the updated document\n        },\n      )\n      .populate('category')\n      .exec();\n\n    if (!faq) {\n      throw new NotFoundException(`FAQ with ID ${id} not found`);\n    }\n\n    return faq;\n  }\n\n  async findPopularFaqs(\n    limit: number = FAQ_CONSTANTS.DEFAULT_POPULAR_LIMIT,\n  ): Promise<FaqDocument[]> {\n    return this.faqModel\n      .find({\n        isVisible: true,\n        deletedAt: null,\n      })\n      .populate('category')\n      .sort({ viewCount: -1 })\n      .limit(limit)\n      .exec();\n  }\n\n  async updateFaq(id: string, updateFaqDto: UpdateFaqDto): Promise<FaqDocument> {\n    const faq = await this.faqModel.findOne({\n      _id: id,\n      deletedAt: null,\n    });\n\n    if (!faq) {\n      throw new NotFoundException(`FAQ with ID ${id} not found`);\n    }\n\n    // Check category exists if being updated\n    if (updateFaqDto.category) {\n      const category = await this.faqCategoryModel.findById(updateFaqDto.category);\n      if (!category) {\n        throw new NotFoundException(`FAQ category with ID ${updateFaqDto.category} not found`);\n      }\n    }\n\n    // Check for order conflicts if category or order is being updated\n    if (updateFaqDto.category || updateFaqDto.order !== undefined) {\n      const categoryId = updateFaqDto.category || faq.category;\n      const order = updateFaqDto.order !== undefined ? updateFaqDto.order : faq.order;\n\n      const existingFaq = await this.faqModel.findOne({\n        _id: { $ne: id },\n        category: categoryId,\n        order: order,\n        deletedAt: null,\n      });\n\n      if (existingFaq) {\n        throw new ConflictException('Another FAQ with this order already exists in this category');\n      }\n    }\n\n    // Use findByIdAndUpdate to perform partial update without triggering validation on unchanged required fields\n    const updatedFaq = await this.faqModel.findByIdAndUpdate(\n      id,\n      { $set: updateFaqDto },\n      { new: true, runValidators: false },\n    );\n\n    return updatedFaq;\n  }\n\n  async removeFaq(id: string, reason?: string, userId?: string): Promise<void> {\n    const faq = await this.faqModel.findOne({\n      _id: id,\n      deletedAt: null,\n    });\n\n    if (!faq) {\n      throw new NotFoundException(`FAQ with ID ${id} not found`);\n    }\n\n    faq.deletedAt = new Date();\n    faq.deleteReason = reason;\n\n    if (userId) {\n      faq.deletedBy = new MongooseSchema.Types.ObjectId(userId);\n    }\n\n    await faq.save();\n  }\n\n  async restoreFaq(id: string): Promise<FaqDocument> {\n    const faq = await this.faqModel.findOne({\n      _id: id,\n      deletedAt: { $ne: null },\n    });\n\n    if (!faq) {\n      throw new NotFoundException(`Deleted FAQ with ID ${id} not found`);\n    }\n\n    faq.deletedAt = null;\n    faq.deletedBy = null;\n    faq.deleteReason = null;\n\n    return faq.save();\n  }\n\n  // FAQ Category CRUD\n  async createCategory(createCategoryDto: CreateFaqCategoryDto): Promise<FaqCategoryDocument> {\n    const existingCategory = await this.faqCategoryModel.findOne({\n      $or: [\n        { 'name.pt-BR': createCategoryDto.name['pt-BR'] },\n        { 'name.en': createCategoryDto.name.en },\n        { order: createCategoryDto.order },\n      ],\n    });\n\n    if (existingCategory) {\n      throw new ConflictException('Category with this name or order already exists');\n    }\n\n    const createdCategory = new this.faqCategoryModel(createCategoryDto);\n    return createdCategory.save();\n  }\n\n  async findAllCategories(): Promise<FaqCategoryDocument[]> {\n    return this.faqCategoryModel.find().sort({ order: 1 }).exec();\n  }\n\n  async findCategoryById(id: string): Promise<FaqCategoryDocument> {\n    const category = await this.faqCategoryModel.findById(id);\n    if (!category) {\n      throw new NotFoundException(`FAQ category with ID ${id} not found`);\n    }\n    return category;\n  }\n\n  async updateCategory(\n    id: string,\n    updateCategoryDto: UpdateFaqCategoryDto,\n  ): Promise<FaqCategoryDocument> {\n    const category = await this.faqCategoryModel.findById(id);\n    if (!category) {\n      throw new NotFoundException(`FAQ category with ID ${id} not found`);\n    }\n\n    // Check for name conflicts if name is being updated\n    if (updateCategoryDto.name) {\n      const nameConflict = await this.faqCategoryModel.findOne({\n        _id: { $ne: id },\n        $or: [\n          { 'name.pt-BR': updateCategoryDto.name['pt-BR'] },\n          { 'name.en': updateCategoryDto.name.en },\n        ],\n      });\n\n      if (nameConflict) {\n        throw new ConflictException('Another category with this name already exists');\n      }\n    }\n\n    // Handle order reordering if order is being updated\n    if (updateCategoryDto.order !== undefined && updateCategoryDto.order !== category.order) {\n      const oldOrder = category.order;\n      const newOrder = updateCategoryDto.order;\n\n      // Check if the new order position exists\n      const targetCategory = await this.faqCategoryModel.findOne({\n        _id: { $ne: id },\n        order: newOrder,\n      });\n\n      if (targetCategory) {\n        // Use a temporary negative value to avoid unique constraint violation during swap\n        const tempOrder = -1 - Date.now(); // Guaranteed unique temporary value\n\n        // Step 1: Move current category to temporary value\n        await this.faqCategoryModel.findByIdAndUpdate(id, {\n          $set: { order: tempOrder },\n        });\n\n        // Step 2: Move target category to old position\n        await this.faqCategoryModel.findByIdAndUpdate(targetCategory._id, {\n          $set: { order: oldOrder },\n        });\n\n        // Step 3: Move current category to new position\n        await this.faqCategoryModel.findByIdAndUpdate(id, {\n          $set: { order: newOrder },\n        });\n\n        // If there are other fields to update, apply them now\n        if (updateCategoryDto.name) {\n          const updatedCategory = await this.faqCategoryModel.findByIdAndUpdate(\n            id,\n            { $set: { name: updateCategoryDto.name } },\n            { new: true, runValidators: false },\n          );\n          return updatedCategory;\n        }\n\n        // Return the updated category\n        return this.faqCategoryModel.findById(id);\n      }\n    }\n\n    // Use findByIdAndUpdate to perform partial update without triggering validation on unchanged required fields\n    const updatedCategory = await this.faqCategoryModel.findByIdAndUpdate(\n      id,\n      { $set: updateCategoryDto },\n      { new: true, runValidators: false },\n    );\n\n    return updatedCategory;\n  }\n\n  async removeCategory(id: string): Promise<void> {\n    // Check if any FAQs are using this category\n    const faqsInCategory = await this.faqModel.findOne({\n      category: id,\n      deletedAt: null,\n    });\n\n    if (faqsInCategory) {\n      throw new ConflictException(\n        'Cannot delete category: FAQs are still assigned to this category',\n      );\n    }\n\n    const result = await this.faqCategoryModel.deleteOne({ _id: id });\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`FAQ category with ID ${id} not found`);\n    }\n  }\n}\n"],"version":3}